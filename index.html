<!DOCTYPE html>
<html lang="es">
<head>
    <title>three.js Mapeo de Textura Proyectivo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #ccc;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 4px;
        }

        a {
            color: #f00;
        }

        #controles {
            position: absolute;
            top: 60px;
            left: 10px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 4px;
        }

        label {
            margin-right: 10px;
        }

        select {
            padding: 5px;
        }
    </style>
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Mapeo de Textura Proyectivo
    </div>

    <div id="controles">
        <label for="seleccionMapeo">Mapeo de Proyección:</label>
        <select id="seleccionMapeo">
            <option value="planar">Planar</option>
            <option value="cubo">Cúbico</option>
            <option value="cilindrico">Cilíndrico</option>
            <option value="esferico">Esférico</option>
        </select>
    </div>

    <!-- Import Map para Resolución de Módulos -->
    <script type="importmap">
        {
            "imports": {
                "three": "./three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

    <!-- Script Principal -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camara, controles, escena, renderizador;
        let modelo;
        let textura;
        let seleccionMapeo;
        let tipoProyeccion = 'planar';

        inicializar();
        animar();

        function inicializar() {
            // Configuración de la Escena
            escena = new THREE.Scene();
            escena.background = new THREE.Color(0xcccccc);

            // Configuración del Renderizador
            renderizador = new THREE.WebGLRenderer({ antialias: true });
            renderizador.setSize(window.innerWidth, window.innerHeight);
            renderizador.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderizador.domElement);

            // Configuración de la Cámara
            camara = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camara.position.set(5, 5, 5);

            // Configuración de OrbitControls
            controles = new OrbitControls(camara, renderizador.domElement);
            controles.enableDamping = true;

            // Configuración de la Iluminación
            const luzAmbiente = new THREE.AmbientLight(0xffffff, 0.3);
            escena.add(luzAmbiente);

            const luzDireccional = new THREE.DirectionalLight(0xffffff, 0.8);
            luzDireccional.position.set(10, 10, 10);
            escena.add(luzDireccional);

            // Cargar Textura
            const cargadorTextura = new THREE.TextureLoader();
            textura = cargadorTextura.load('textura.jpg', () => {
                textura.wrapS = THREE.ClampToEdgeWrapping;
                textura.wrapT = THREE.ClampToEdgeWrapping;
                textura.minFilter = THREE.LinearFilter;
            }, undefined, (error) => {
                console.error('Error al cargar la textura:', error);
            });

            // Cargar Modelo GLB
            const cargadorGLB = new GLTFLoader();
            cargadorGLB.load(
                'suzanne.glb', // Reemplaza con la ruta correcta a tu modelo GLB
                function (gltf) {
                    modelo = gltf.scene;
                    modelo.traverse(function (hijo) {
                        if (hijo.isMesh) {
                            // Reemplazar material con material de shader personalizado
                            hijo.material = crearMaterialProyectivo(hijo.material);
                        }
                    });
                    escena.add(modelo);
                },
                undefined,
                function (error) {
                    console.error('Ocurrió un error al cargar el modelo GLB:', error);
                }
            );

            // Desplegable para Mapeo de Proyección
            seleccionMapeo = document.getElementById('seleccionMapeo');
            seleccionMapeo.addEventListener('change', function (evento) {
                tipoProyeccion = evento.target.value;
                actualizarTipoProyeccion();
            });

            // Manejar Cambio de Tamaño de Ventana
            window.addEventListener('resize', alRedimensionarVentana, false);
        }

        /**
         * Crea un ShaderMaterial personalizado con mapeo de textura proyectivo.
         * @param {THREE.Material} materialOriginal - El material original de la malla.
         * @returns {THREE.ShaderMaterial} - El material de shader personalizado.
         */
        function crearMaterialProyectivo(materialOriginal) {
            // Definir uniforms
            const uniforms = {
                uTextura: { value: textura },
                uTipoProyeccion: { value: obtenerValorTipoProyeccion(tipoProyeccion) },
                uDireccionLuz: { value: new THREE.Vector3(10, 10, 10).normalize() },
                uLuzAmbiente: { value: new THREE.Color(0xffffff).multiplyScalar(0.3) },
                uColorLuzDireccional: { value: new THREE.Color(0xffffff).multiplyScalar(0.8) }
            };

            // Crear ShaderMaterial
            const materialShader = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `
                    varying vec3 vPosicionMundo;
                    varying vec3 vNormal;

                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vec4 posicionMundo = modelMatrix * vec4(position, 1.0);
                        vPosicionMundo = posicionMundo.xyz;
                        gl_Position = projectionMatrix * viewMatrix * posicionMundo;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTextura;
                    uniform int uTipoProyeccion;
                    uniform vec3 uDireccionLuz;
                    uniform vec3 uLuzAmbiente;
                    uniform vec3 uColorLuzDireccional;
                    varying vec3 vPosicionMundo;
                    varying vec3 vNormal;

                    void main() {
                        vec2 uvProyectado;
                        if (uTipoProyeccion == 0) { // Planar
                            // Proyección sobre el plano XZ
                            uvProyectado = vPosicionMundo.xz * 0.1 + 0.5;
                        }
                        else if (uTipoProyeccion == 1) { // Cúbico
                            // Mapeo cúbico basado en el eje dominante
                            vec3 normalAbs = abs(vNormal);
                            if (normalAbs.x > normalAbs.y && normalAbs.x > normalAbs.z) {
                                uvProyectado = vec2(vPosicionMundo.z, vPosicionMundo.y) * 0.1 + 0.5;
                            }
                            else if (normalAbs.y > normalAbs.x && normalAbs.y > normalAbs.z) {
                                uvProyectado = vec2(vPosicionMundo.x, vPosicionMundo.z) * 0.1 + 0.5;
                            }
                            else {
                                uvProyectado = vec2(vPosicionMundo.x, vPosicionMundo.y) * 0.1 + 0.5;
                            }
                        }
                        else if (uTipoProyeccion == 2) { // Cilíndrico
                            // Mapeo cilíndrico alrededor del eje Y
                            float theta = atan(vPosicionMundo.z, vPosicionMundo.x) / (2.0 * 3.14159265359) + 0.5;
                            float y = (vPosicionMundo.y * 0.1) + 0.5;
                            uvProyectado = vec2(theta, y);
                        }
                        else if (uTipoProyeccion == 3) { // Esférico
                            // Mapeo esférico
                            float theta = atan(vPosicionMundo.z, vPosicionMundo.x) / (2.0 * 3.14159265359) + 0.5;
                            float phi = asin(vPosicionMundo.y / length(vPosicionMundo)) / 3.14159265359 + 0.5;
                            uvProyectado = vec2(theta, phi);
                        }
                        else {
                            uvProyectado = vec2(0.0, 0.0);
                        }

                        // Muestrear la textura
                        vec4 colorTextura = texture2D(uTextura, uvProyectado);

                        // Iluminación Difusa Básica
                        float difuso = max(dot(vNormal, uDireccionLuz), 0.0);
                        vec3 iluminacion = uLuzAmbiente + uColorLuzDireccional * difuso;

                        // Combinar textura con iluminación
                        gl_FragColor = vec4(colorTextura.rgb * iluminacion, colorTextura.a);
                    }
                `,
                lights: false
            });

            return materialShader;
        }

        /**
         * Actualiza el tipo de proyección en los uniformes de todos los materiales de las mallas.
         */
        function actualizarTipoProyeccion() {
            if (!modelo) return;
            modelo.traverse(function (hijo) {
                if (hijo.isMesh && hijo.material.uniforms) {
                    hijo.material.uniforms.uTipoProyeccion.value = obtenerValorTipoProyeccion(tipoProyeccion);
                }
            });
        }

        /**
         * Convierte el tipo de proyección de cadena a valor entero.
         * @param {string} tipo - El tipo de proyección como cadena.
         * @returns {number} - El valor entero correspondiente.
         */
        function obtenerValorTipoProyeccion(tipo) {
            switch (tipo) {
                case 'planar':
                    return 0;
                case 'cubo':
                    return 1;
                case 'cilindrico':
                    return 2;
                case 'esferico':
                    return 3;
                default:
                    return 0;
            }
        }

        /**
         * Maneja los eventos de cambio de tamaño de la ventana.
         */
        function alRedimensionarVentana() {
            camara.aspect = window.innerWidth / window.innerHeight;
            camara.updateProjectionMatrix();

            renderizador.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Bucle de animación.
         */
        function animar() {
            requestAnimationFrame(animar);
            controles.update();
            renderizador.render(escena, camara);
        }
    </script>
</body>
</html>

